[toc]





### 接口拦截 

#### 小程序  uni.reques()

利用 [symbol](https://zhuanlan.zhihu.com/p/22652486) 创建基础配置项：config 

设置拦截器处理请求和响应

封装一个 request 函数，对配置项进行处理，比如 url 拼接，添加请求头等。返回一个 Promise，Promise 里处理微信 API 的 success 和 fail。

用Object.definProperty() 在 vue.prototype 上定义一个新属性用来调用封装的请求处理函数，用 [vue.mixin](https://cn.vuejs.org/v2/guide/mixins.html)进行全局混入。

#### PC  ajax 或 axios（js技术）

axios 是利用 promise 对 ajax 技术的一种封装，ajax是针对 MVC 的编程，axios提供了一些并发请求的接口

#### XMLHTTPRequest（浏览器对象）[参考链接](https://segmentfault.com/a/1190000004322487)

1.创建 xmlhttprequest 实例  const xml = new XMLHTTPRequest

2.设置方法，url，是否异步  xml.open("get", url, true) [第三个参数表示是否异步，true会在 send() 后执行]

post 需要设置请求头 setRequestHeader() [open() 之后,send()之前调用]

3.发送参数  xml.send (params)

4.注册事件  xml.onreadystatechange() 可以监测到 readyState 的变化

状态（5）：0 - 初始状态，未打开，1 - 已打开未发送， 2 - 已获取响应头，3 - 正在下载响应体， 4 - 传输完成

事件（7）：onreadystatechange()，onloadstart()，onprogress()，onload()，onloadend()，onabort()[终止该请求，readystate=0,不处罚onreadystatechange()]，ontimeout()，onerror() 

##### 兼容性

![image-20210702103242608](C:\Users\zenglingqian\AppData\Roaming\Typora\typora-user-images\image-20210702103242608.png)

#### mixins 

全局mixins   Vue.mixins

局部mixins   新建minxin文件 

```javascript
const mixin = {}
export {mixin}
```



#### 自定义指令

用 vue.directive 注册或者获取指令。

全局 Vue.directive

```javascript
Vue.directive('focus', {
  // 当被绑定的元素插入到 DOM 中时……
  inserted: function (el) {
    // 聚焦元素
    el.focus()
  }
})
```

局部注册，组件中接受directive

```javascript
directives: {
  focus: {
    // 指令的定义
    inserted: function (el) {
      el.focus()
    }
  }
}
```



#### vue双向绑定[参考](https://www.jianshu.com/p/5fe2664ff5f7)

通过 Object.defineProperty()  来实现数据劫持以及发布者-订阅者模式

vue实例会去遍历所有的属性，为每个属性添加 get 和 set 方法进行数据劫持

Observe 进行监听，属性改变就通知订阅者管理器（dep），是否需要进行视图的改变。用Compile对每个节点进行扫描和解析指令进行解析，初始化一个订阅器 Watcher。由watch进行对比后确定是否进行View渲染。



#### 跨域+安全防范

原因：浏览器同源策略（协议，域名，端口）

解决方案：1.jsonp+script

​                   2.iframe+form

​                   3.cors

​                   4.nginx



#### 新特性合集

##### html5 新特性

1.canvas

2.语义化标签   h1— h6，article，footer，nav，strong 等

3.媒体播放 video 和 audio

4.本地存储 localStorage 和 sessionStorage

5.Form Data 对象

6.PostMessage

7.通信协议 websocket [参考](https://www.ruanyifeng.com/blog/2017/05/websocket.html)

8.多任务 webworker [参考](http://www.ruanyifeng.com/blog/2018/07/web-worker.html)

9.离线应用 manifest

10.history (window对象)

##### css3 新特性

1.选择器 nth-child(d)

2.flex

3.媒体查询 @media

4.动画

5.圆角，渐变，阴影

##### ES6 新特性

1. let 和 const
2. 模板字符串 ``
3. 解构  [x,y,z] = [10,25,-34]
4. 扩展运算符 ...
5. 对象字面量写法
6. 箭头函数 () => {}
7. super 和 extend
8. Promise

 



## CSS[参考](http://caibaojian.com/css3/properties/animation/animation.htm)

##### 盒子模型

IE：width(content+padding+border) + margin

W3C：width(content) + padding + border + margin

转换：box-sizing: content-box (W3C) / border-box (IE)



##### a标签四个伪类执行顺序

lova hate: link  visited   hover  active



##### css选择符

1. id选择器

2. 类选择器

3. 标签选择器

4. 子代选择器

5. 相邻选择器

6. 后代选择器

7. 通配符选择器

8. 属性选择器

9. 伪类选择器

   

##### CSS优先级 （就近原则）

用户自定义样式 > 网页自定义样式 > 浏览器默认样式

1. !important  （可以使网页自定义样式 > 用户自定义样式）
2. 行内样式  1000
3. id选择器   0100
4. class类名，属性，伪类   0010
5. 标签选择器    0001



##### 隐藏页面元素

1.display: none   渲染树不占据空间，dom节点可见，不可继承属性，回流

2.visibility: hidden   渲染树占据空间，dom节点可见，继承属性，重绘

3.负margin

4.transform: scale(0,0)

5.opacity:0

```js
v-if 和 v-show:
v-if 操作dom元素节点，v-show 仅改变display样式
// 不涉及权限，安全页面展示的情况下使用v-show
```



##### 重绘和回流/重排

重绘：不影响布局

重排：影响布局。js 获取 Layout 产生重排



##### css3动画

1.animation 

​     复合属性  animation-name / animation-duration /  -timing-function /   -delay 等。

@keyframes 关键帧 from to 

```js
@keyframes animations{
	0%{transform:scale(0);opacity:0;}
	40%{transform:scale(1);opacity:1;}
	100%{opacity:1;}
}
```

2. transition

   复合属性 transition-property（属性值） / -duration / -timeing-function（速度曲线） / -delay

   特性：1.需要具体属性和事件触发

   ​            2.一次性，不能重复发生，可多次触发

   ​            3.只有两个状态。开始和结束。

   ​            4.一条transition只能定义一个属性。

##### link 和 import

1.link 是 html 方式，@import 是 css 方式

2.link 可并行下载，@import 过多嵌套可能导致串行下载，出现 FOUC（先使用浏览器默认样式后加载样式表导致页面闪烁，样式表放到文档的 head）



##### flex

tip：设置后子元素 float，clean，vertical-align 都失效

###### 容器属性

1. 决定主轴方向 （第一个为默认）

```css
flex-direction: row | row-reverse | column | column-reserve
```

2. 换行

```css
flex-wrap: nowrap | wrap | wrap-reverse
/* wrap-reverse 换行，第一行在下 */
```

3. flex-direction 和 flex-wrap 的简写形式

```css
flex-flow: row-reverse nowrap
```

4.主轴对齐方式

```css
justify-content: flex-start | flex-end | center | space-between | space-around
```

![image-20210730151601946](C:\Users\zenglingqian\AppData\Roaming\Typora\typora-user-images\image-20210730151601946.png)

5.交叉轴对齐方式

```css
align-items: flex-start | flex-end | center | baseline | stretch
```

![image-20210730151940843](C:\Users\zenglingqian\AppData\Roaming\Typora\typora-user-images\image-20210730151940843.png)

6.多轴对齐

```css
align-content: flex-start | flex-end | center | space-between | space-around | stretch
```

![image-20210730153218274](C:\Users\zenglingqian\AppData\Roaming\Typora\typora-user-images\image-20210730153218274.png)

###### 项目属性

1.排列顺序，越小越靠前，默认为0

```css
order: 0
```

2.放大比例，默认为0，不放大

````css
flex-grow: 2
````

![image-20210730154737233](C:\Users\zenglingqian\AppData\Roaming\Typora\typora-user-images\image-20210730154737233.png)

3.缩小比例，默认为1，空间不足，项目将缩小。0 不缩小

```css
flex-shrink: 1
```

4.占据主轴空间[参考](https://blog.csdn.net/lmmxxoo/article/details/83094818)

```css
flex-basis: 350px
```

5.flex属性 flex-grow，flex-shrink，flex-baseis 缩写 默认值 0 1 auto

6.允许单个项目对齐方式不同

```css
align-self: auto | flex-start | flex-end | center | baseline | stretch
```



##### px，em，rem

px：相对长度单位

em：继承父元素字体大小  

rem：相对根元素字体大小

谷歌字体小于12px：transform: scale(0.7)



##### 修改页面初始根元素字体大小

```js
// 第一步： 获取根元素
// 第二步： 设置1rem的比例
// 第三步： 监听resize事件
// 1rem = 20px
(function() {
   const html = document.documentElement
   function onWindowResize() {
       html.style.fontSize = html.getBoundingClientRect().width/ 20 + 'px'
   }
   window.addEventListener('resize',onWindowResize)
    onWindowResize()
})()
```

设置meat头禁止用户缩放

<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable='no'" >



##### 修改谷歌自动填充的黄色背景

1.关闭form的自动填充：autocomplete="off"

2.修改input 背景色

```css
input:-webkit-autofill { background-color:transparent; }
```



##### font-style

font-style: italic / oblique 【倾斜字体，可继承】



##### 让页面字体变细变清晰（ios手机浏览器字体齿轮设置）

```css
/* 属性可以使页面上的字体抗锯齿 */
-weblit-font-smoothing: antialiased;
```



#### position，display，float

1.position：static /  absolute（绝对定位，最近的**已定位祖先元素**） / fixed（相对于浏览器窗口） / relative（相对于自身在普通文档流中的位置定位） / inherit

2.display：block / inline / inline-block / none / table / list-item / inherit

3.float：left / right / none / inherit （类似于inline-block；因为默认宽度不是100%，magin或padding有效）



##### 伪类伪元素区别

伪元素(::)：在页面中生成不存在的元素，只在外部展示，不显示在dom中。::before 和 :before 都是伪元素，:before是css1语法。

伪类(:): 将css样式添加到选择器上。



#### BFC[参考](https://zhuanlan.zhihu.com/p/25321647)

##### 触发条件（更改静态布局）

1. float
2. overflow （visible除外）
3. display  : table-cell，table-caption，inline-block
4. position（static 和 releative 除外）

#### 特性

1.浮动元素会被计算高度

2.非浮动元素不会覆盖浮动元素位置

3.不同 BFC 的 margin 不会相互重叠

```
外边距塌陷: 只发生在上下边距上，父子关系和相邻关系触发。
原因：子元素找不到父元素的border或padding，就会与上边距重叠。
```

 应用

1.阻止margin重叠

2.阻止非浮动元素会覆盖浮动元素位置



##### 清除浮动[参考](https://www.cnblogs.com/lauzhishuai/p/10953608.html)

1. 空标签清除浮动

   ```css
   .clear{
       clear:both
   }
   ```

2. :after伪类清除浮动

   ```css
   :after{
      content: '';
      height: 0;
      display: block;
      clear: both;
   }
   ```

3. 父元素设置overflow:hidden

4. 给需要清除浮动的元素添加 clear属性(浮动元素在前)

   ```css
   clear: none/left/right/both 
   inherit
   ```



##### 媒体查询@medoa(响应式基本原理)



##### height 和 inline-height[参考](https://www.zhangxinxu.com/wordpress/2009/11/css%E8%A1%8C%E9%AB%98line-height%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8/)

div 的高度在无 height 下由inline-height决定。height 会触发 haslayout，line-height 不会。

line-height 指的是下一行基线到上一行基线的距离。

line-height赋值

1.纯数字：按父元素字体大小比例传给后代

2.百分比：按父元素字体大小计算后的值传给后代

3.px：固定值



##### inline-block 间隙

原因：有空格或换行

解决：1.移除空格或换行

​            2.font-size:0 （可清除图片，无文字）

​            3.letter-spacing （字间距）

​            4.word-spacing    (词间距)

 

#### CSS性能优化

1.不用@import，css放在head中

2.尽量用复合属性，合理使用选择器

3.css压缩与合并，gzip压缩

4.避免使用CSS表达式，移除空的css规则

```css
/*css表达式*/
top: expression(body.scrollTop + 50 + 'px')
```

5.充分利用继承属性，减少代码量



##### 浏览器解析css

从右到左



##### base64好处

1.减少http请求

2.可以加密



#### 布局

##### 垂直水平居中

1.flex

```css
display: flex;
justify-content: center;
align-items: center;
```

2.有固定宽高(width:100px;height:100px;)

```css
position: relative;
top: 50%;
left: 50%;
margin-top:-50px;
margin-left:-50px;
```

```css
position: absolute;
top: 0;
left: 0;
right: 0;
bottom: 0;
margin: auto;
```

3.无固定宽高

```css
postion: relative;
left: 50%;
top: 50%;
transform: translate(-50%, -50%)
```

4.table

```css
display: table-cell;
text-align: center;
vertical-align: center;
```



##### 双飞翼

3.圣杯布局



## JS

#### 闭包和垃圾回收[参考](https://blog.csdn.net/kk211814/article/details/88323872)

闭包概念：读取其他函数内部变量的函数

闭包特性：

       1. 函数内再嵌套函数。
       2. 内部函数可以引用外层的参数和变量。
       3. 参数和变量不会被垃圾回收机制回收。

闭包作用：设计私有的方法和变量。可以避免全局变量污染，让变量始终在内存中。

闭包存放在堆中。

垃圾回收机制：1.清除没有被引用的变量；

​                           2.根访问不到的变量

清除方法[参考](https://blog.csdn.net/zhouziyu2011/article/details/61201613)：1.标记清除（进出环境进行标记）；2.引用计数

V8垃圾回收机制：基于分代式垃圾回收机制(并行回收)

分为新生代和老生代，新生代保存时间短的对象，老生代保存时间长的对象。

新生代主要采用scavenge算法，该算法将新手空间分为两部分，一部分为from，一部分为to。

首先检测from部分，检测到有存活的移动到to，然后释放from，再将to的存活对象移动到from。

多次复制后仍存活则晋升为老生代。（to空间超过限制也会晋升）

老生代采用Mark-sweep 和Mark-compact相结合的算法。（因为老生代的活动对象多，采用scavenge算法浪费空间且效率低）

Mark-sweep:标记清除。标记时采用增量标记，与js逻辑交替进行。

Mark-compact:标记移动。由于Mark-sweep清除后会产生部分空缺，需要将活动对象往一边堆叠。

清除方法[参考](https://blog.csdn.net/zhouziyu2011/article/details/61201613)：1.标记清除【V8】（进出环境进行标记）；2.引用计数（创建对象时会产生引用计数对象，被引用时加1，反之减1，为0时被回收）

闭包造成内存泄漏的原因：内部函数引用了外层变量，导致无法被垃圾回收机制回收。

###### 内存泄漏的几种情况

1. 未使用的var变量
2. console.log
3. 闭包
4. setTimeout 第一个参数为字符串
5. 循环引用



#### 作用域链和执行上下文栈

作用域链概念：

保证执行环境有权访问的变量和函数是有序的，只能向上访问，访问到 window 对象停止。作用域控制着变量与函数的可见性及生命周期。只引用不包含实际变量对象。

执行上下文：

概念：js执行代码时的运行环境。确定该函数执行期间用到的变量：this、变量、函数等。

1.全局执行上下文

2.函数执行上下文

3.eval执行上下文（eval：将对应字符串解析成 js 代码并运行。）

属性：变量对象 (VO) 和作用域链 

语法作用域：

由代码中函数声明的位置来决定的。



#### 原型和原型链

:link:https://www.zhihu.com/question/34183746

:link:https://blog.csdn.net/xiaoermingn/article/details/80745117

:link:https://blog.csdn.net/aitangyong/article/details/44837655

每个对象都有prototype属性，当访问一个对象某属性时，若找不到该属性，就会往prototype访问，直到null结束。

prop：指向构造函数的prototype

prototype：包含构造函数的方法和属性

关系：instance.constructor.prototype = instance._prop_

constructor：用来引用函数本身

特点：通过引用来传递的，修改原型时，相关对象也会继承这一改变

原型：每个对象都有[_prop_]内部属性，这个属性对应的就是对象原型。除此之外还预置了prototype属性，用构造函数创建实例时，实例的[_prop_]就是prototype。

原型链是基于_prop_形成的，继承通过prototype

对象_prop_ = new constroct().prototype



#### 继承

1.原型链继承

```js
function father() {
    const a = 10
}
function child() {}
child.prototytpe = new father() // 实例的prototype = constructor.prop
// a.对象实例共享所有继承的属性和方法
// b.创建子类型的实例的时候，不能传递参数
```

2.构造函数继承

```js
function father() {
    const a = 10
}
function child() {
   father.call(this) 
}
let a = new child()
```

3.组合继承(原型链+构造函数)

```js
function father() {
    const a = 10
}
function child() {
   father.call(this) 
}
child.prototytpe = new father()
```

4.寄生组合继承

```js
function father() {
    const a = 10
}
function child() {
   father.call(this) 
}
child.prototytpe = Object.create(father.prototype)
```

5.class继承 (ES6继承)

```js
class A extends B {}
// 向父类传参 super
```

###### ES5和ES6继承区别

1. ES6用super()拿到子类，ES5通过apply绑定
2. 类声明不会提升



##### 构造函数和new

new操作符: 调用构造函数，为实例和构造函数（普通函数用于创建一类对象时）建立了一条原型链

```js
let obj={}
obj._prop_ = CO.prototype
CO.call(obj)
return obj
```



##### 事件代理

原理：事件冒泡，将子元素的事件委托给父元素，优点是可以提高性能，新增子对象时无需再次对其绑定。

######  事件流

事件捕获 -> 事件冒泡

【从window往下到目标节点】-> 【目标节点往上到window】

低版本IE不支持事件捕获

阻止捕获：

```js
e.preventDefault()
// IE
e.returnValue = false
// Vue
@click.prevent = "functionName"
```

阻止冒泡：

```js
e.stopPropagation()
// IE
e.cancelBubble = true
// Vue
@click.stop = "functionName"
```



##### 原生事件

###### 绑定事件

onclick

````js
// 同一事件会被覆盖掉
let btn = document.getElementById('btn')
btn.onclick() = function () {}
````

addEventLisener

```js
// 不兼容IE6-8
// 同一事件正序触发
let btn = document.getElementById('btn')
btn.addEventLisener(event,fn,false) // true 只在捕获阶段处理；flase(默认) 只在冒泡阶段处理
// 移除 removeEventLisener 参数同addEventLisener
```

attachEvent

```js
// 兼容IE6-8
// 同一事件倒叙触发
// 必须带on
let btn = document.getElementById('btn')
btn.attachEvent(onEvent,fn)
// 移除 detachEvent 参数同attachEvent
```

###### 页面加载事件方法

window.onload

页面所有元素加载完成后执行

$(document).ready

dom结构完成后执行

###### 自定义事件

dispatchEvent 分发。addEventListener 调用。

new Event

```js
// 不带参数
let event = new Event(event, configObj)
btn.dispatchEvent(event)
```

new CustomEvent

```js
let event = new CustomEvent(event,detail:{params},configObj)
```



##### 单线程，异步和evenloop

###### 单线程

只有一个线程，只能做一件事

原因：避免dom渲染的冲突。

浏览器需要渲染dom，js可以修改dom结构。js执行的时候，浏览器dom渲染会暂停，两段js不能同时执行。

###### evenloop

一种系统运行机制，用于等待和发送消息，一个进程可以包括多种线程，因为js是单线程，为了避免网页假死的情况。（异步）

任务执行顺序

宏任务(setTimeout、setInterval)

微任务(promise)

1.执行同步代码，宏任务

2.查询微任务

3.执行微任务

4.渲染UI

5.下一轮event Loop

###### nodejs Eventloop

:link:https://www.jianshu.com/p/2b34a257108d

分为6个阶段

timmer : 调用setTimeout，setTimeInterval

I/O callback ：处理系统调用错误

prepare ：node内部使用

poll ：获取新的 I/O 事件

check ：执行setImmediate()

close callback ：执行socket的close事件

###### 区别

nodejs：microtask在事件循环的各个阶段之间执行。

浏览器：macrotask执行之后执行

###### webworker

在后台独立运行的脚本，不会影响页面性能。

不能跨域访问JS。

支持多线程但是不能访问dom，常用于需要消耗大量时间和cpu资源的复杂计算。



##### this（函数执行上下文）

1.普通函数：指向window

2.箭头函数：本身无this，指向调用它的普通函数。一但绑定不可更改。

3.new：指向实例（原因见new操作符的操作）

4.call()，apply()，bind() 可以改变this指向，取决于第一个参数，为null指向window。箭头函数使用无效。

|          | call                  | apply                 | bind                  |
| -------- | --------------------- | --------------------- | --------------------- |
|          | 立即改变              | 立即改变              | 下次调用后改变        |
| 调用参数 | call(this, arg1,arg2) | apply(this,arguments) | bind(this, arg1,arg2) |
| 性能最好 | √                     |                       |                       |

```js
// 手写call,apply,bind
Function.prototype.myCall(context, ...args) {
    context = (context === null || context === undefined) ? window : context
    context._fn = this
    let result context._fn(...args)
    delete context._fn
    return result
}
Function.prototype.myApply(context, args) {
    context = (context === null || context === undefined) ? window : context
    context._fn = this
    let result context._fn(...args)
    delete context._fn
    return result
}
Function.prototype.mybind(context, ...args1) {
    context = (context === null || context === undefined) ? window : context
    let _this = this
    return function (...args2) {
        context._fn = _this
        let result = context._fn(...[...args1,...arg2])
        delete context._fn
        return result
    }
}
```



##### Ajax和websocket

###### Ajax

五部曲

```js
// 1. 创建对象
var xhr = new XMLHttpRequest()
// 2. 连接服务器
xhr.open('get', url, true)  // 为true时为异步
// 3. 发送请求
xhr.send(params)
// 4. 接受请求
xhr.onreadStatechange = function() {
    // 5. 处理请求
    if(xhr.readyState == 4) {
        if(xhr.status == 200) {
            success(xhr.responseText)
        }else {
            fail && fail(xhr.status)
        }
    }
}
// readyState
// 0 未初始化；1 载入中；2 载入完成；3 处理中；4 处理完成
```

优点：

1.分担服务器压力，让一部分功能在客户端承担

2.通过异步模式，提升了用户体验

3.优化了浏览器和服务器传输，减小了带宽占用

4.支持局部刷新

缺点：

1.ajax暴漏了与服务器交互细节

2.不易调试

3.对搜索引擎支持较弱

###### webSocket

原理：http握手+tcp数据传输

特点：

1.建立在TCP上，服务器端容易实现。

2.与http兼容性好，握手阶段采用http协议，能通过http代理服务器

3.数据格式轻量，性能开销小，通信高效

4.无同源限制

5.可以发送文本或二进制数据

6.协议标识符ws（加密wss）

```js
// readstate
// 0 正在链接；1 连接成功可以通信； 2 正在关闭；3 已关闭或连接失败
// 1. 生成实例
var ws = new WebSocket(url) // wss://开头
// 2. 连接
ws.onopen = () => {
    ws.send(query)
}
// 3. 通信处理
ws.onmessage = () => {
    ws.close()
}
// 4. 关闭连接后的回调处理
ws.onclose = () => {}
```



##### 跨域

产生原因：浏览器的同源策略

同源限制：ip，端口，协议，域名任一不同视为不同源

解决办法

1.jsonp

原理：利用script标签无跨域限制的漏洞。

```js
var script = document.createElement('script')
script.type = 'text/javascript'
script.src = 'http://www.xxxxx.xom?callbanck=onBAck'
document.head.appendChild(script)
function onBack(res) {
    console.log(Res)
}
```

2.document.domain + iframe （主域相同，子域不同）

![image-20210803135436793](C:\Users\zenglingqian\AppData\Roaming\Typora\typora-user-images\image-20210803135436793.png)

3.nginx代理

4.CORS

简单请求：头部信息中请求时新增一个Origin字段【浏览器自动添加】。

Access-Control-Allow-Origin：*

非简单请求(PUT，DELETE)：进行http预检（发送OPTIONS），确定来源。通过后后续同简单请求。

##### XSS和CSRF

###### XSS

概念：注入恶意代码到网页，使用户加载并执行攻击者的程序。

类型：

1.反射型

xss代码在url中，用户提交到服务器后，服务器解析后随响应返回给浏览器，浏览器执行xss代码。

2.存储型

提交的xss代码会存储到服务器。随下次请求返回。例如评论输入了xss代码，其他用户点击这条xss评论后会被攻击。

3.基于DOM

纯客户端攻击，修改页面的DOM结构。

防范：

1. head设置 httponly，js脚本无法获取
2. 对用户的输入进行encode处理

###### CSRF

概念：挟持用户的已登录信息做出非用户本意的行为。

防范：

1.设置验证码

2.利用token

###### 区别

xss是获取信息，不需要知道用户页面的代码和数据包，csrf是代替用户完成操作，需要知道其他用户页面的代码和数据包。

###### 加密算法

1.MD5加密

2.SHA256加密



##### XML和JSON

|          | XML      | JSON         |
| -------- | -------- | ------------ |
| 数据体积 | 比json大 | 小           |
| 传输速度 |          | 快           |
| 数据交互 |          | 更易解析处理 |
| 数据描述 | 好       |              |



##### 对象

定义方法：

1.字面量

```js
const obj = {}
```

2.构造函数

```js
const obj = new Object()
```

3.Object.create()

```js
const obj = Object.create(Object.prototype)
```



##### 浏览器兼容问题



##### Promise

原理：回调函数

状态：pending，fulfilled，rejected

一旦确定不可更改

方法

```js
// 1.promise.then()
// 2.promise.catch()
// 3.promise.finally()
// 4.promise.all([promiseArr]) 一个失败就全为失败，返回第一个失败的结果
// 5.prommise.any([promiseArr]) 一个成功就返回成功，返回的是第一个成功的值
// 6.promise.race([promiseArr])  只要有一个完成就完成，无论成功还是失败
```

Async await: Generator 函数语法糖，将异步转为同步形式

Promise 缺点

1.处于pedding时不能确定是刚开始还是快结束；

2.一旦开始不能停止；

3.不设置回调函数，Promise内部错误不反映到外部；





##### 数据类型

基础数据类型【栈】：Boolean，Number(NaN)，String，Undefined，Null（空对象指针）

引用数据类型【堆】：Object，Symblo



##### 判断数据类型

1.typeof

```js
// null 无法判断, 是因为js最初的机制导致的。由于 null 的标签值是0x00，而对象的类型标签是 0，所以typeof判断null为Object
typeof('111') // string
typeof(null) // Object
```

2.instanceof（查找原型链，left._prop_ === right.prototype）

```js
// 只能判断两个对象是否属于实例关系，无法检测undefined和null
arr instanceof Array // true
Object instanceof Object // true
Object instanceof Function // true
// Object = new Object()
Function instanceof Function // true
// Function = new Function()
```

区别

```js
// typeof用来检测原型值
// instanceof用来检测对象类型
```

手写instanceof

```js
function myInstanceof(left,right) {
    let L = left._prop_
    let R = right.prototype
    while(true) {
        if(L === null) return false
        if(L._prop_ === R.prototype) return true
        L._prop_ = L.prototype
    }
}
```



3.constructor（用来引用构造函数本身）

```js
// 无法判断null和undefined，因为null和undefined是无效对象，因此没有constructor存在
'111'.constructor === String // true
```

4.toString

```js
// 最完美
Object.prototype.toString.call(1111) // [Object Number]
```

toString() 和 Object.prototype.toString.call()区别

```js
// Array 和 Function 都是重写了toString方法的
```

数组判断 isArray()

```js
let a = [1,2,3]
Array.isArray(a) // true
```



##### NaN ， Undefined 和 Null

```js
0 == undefined  // false
0 == null // false
0 == NaN //false
undefined == null // true
undefined === null // false
undefined == NaN // false
null == NaN // false
```

NaN：非数值，属于Number，可以用Number.isNaN()来判断

undefined: typeof(undefined) // undefined

1. 表示已声明但未定义的值
2. 函数无返回值，有未被赋值的对象
3. 转化为NaN

```js
Number(undefined) // NaN
Number(undefined+10) // NaN
```

null：typeof(null) // object

1.表示无值

2.原型链终点

2.转化为0

```js
Number(null) // 0
Number(null+10) // 10
```



##### 数组和对象





##### js延迟加载

1. <script>设置defer

   defer 和 async 的区别

   defer：并行加载，按照页面script顺序执行下载完

   async：并行加载，下载完立即执行

2. 动态创建script

3. xmlhttpRequest注入

4. 延迟加载工具lazyLoad



##### 严格模式限制

使用方式：use  strict

限制：

1.变量必须声明后使用；

2.函数参数不能有同名属性

3.不能对只读属性赋值

4.禁止this指向全局对象

5.不能删除不可删除的属性

6.不能使用arguments.callee 和 argguments.caller

7.新增了保留字（例如 static，interface，protected）



##### ES6 新增特性

1.新增模板字符串

2.箭头函数

3.let 和 const

4.块级作用域

5.Promise



##### SET 和 MAP

MAP（字典）：类似于es5的对象，有键值对，key可以为任何值，无重复值

```js
let a = new.Map()
// 新增
a.set(a,1) // {a => 1}
// 读取
a.get(a)  // 1
// 查找
a.has(a)  // true
// 删除
a.delete(a) // {}
// 长度
a.size // 1
```

SET（集合）: 类似于数组，无重复值，可以数组去重

```js
let a = [1,2,4,2,3]
// 去重
let b = [...new Set(a)]
// 交集
let c = [1,6,5,3,2]
let s1 = [...new Set(c)]
let arr = b.filter(item => {
    return s1.has(item)
})
// 并集
let arr = b.filter(item => {
    return !s1.has(item)
})
```



##### 箭头函数和普通函数区别

1.this指向

2.不可以当构造函数

3.不可以使用arguments对象，可以用rest参数代替

4.不能用作generator函数

###### arguments和rest

arguments不是纯数组，转换方法：1.Array.prototype.slice.call(arguments)

2.ES6 Array.from(arguments)

使用

```js
// arguments
function add(num1,num2) {
    var res2 = arguments[0]+arguments[1]
    return res2
}
//rest 只能放在最后一个参数，并且有...为前缀
function add(num1,num2,..theArgs) {
    console.log(Args.length)
}
```



##### 循环遍历

###### 数组遍历

1.for  (可以使用break，continue，return)

2.for..in,,  (可以使用break，continue，return)

```js
// 用于遍历对象，但是也可以遍历数组
const arr = [1,2,3]
for(var i in arr) {
    console.log(i+":"+arr[i])
}// 1  2  3
```

3.for..of

```js
// 可以使用break,continue，不可以用return
const arr = [1,2,3]
for(var i of arr) {
    console.log(i)
}// 1  2  3
```

4..Array.foreach

```js
// 不可以使用break，return只是跳出当前循环，不会中止foreach，可以用try抛出错误中止
const arr = [1,2,3,4,5]
arr.foreach(item => {
    console.log(item)
    if(item === 3) {
        console.log('item')
        return
        console.log('return')
    }
}) // 1  2  3  item  4  5

const arr = [1,2,3,4,5]
try{
   arr.foreach(item => {
        console.log(item)
        if(item === 3) {
            console.log('item')
            throw new error
            console.log('return')
        }
	})
}catch {
    console.log("catch")
} // 1  2  3  item  catch
```

5.Array.map

```js
// 不能用break；return跳出当前循环，会返回新数组，可以用try打断
const arr = [1,2,3]
let a = arr.map(item => {
    return item*2
})// [2,4,6]
```

6.Array.filtter

```js
// 不能用break；return跳出当前循环，会返回新数组，可以用try打断
const arr = [1,2,3]
let a = arr.map(item => {
   return item > 2
})// [2,4,6]
```

7.Array.some

```js
//用于检测数组中的元素是否满足指定条件,返回值为布尔
//如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测
//如果没有满足条件的元素，则返回false
//some不会改变原数组，some不会检查空数组
// 不能用break；return跳出当前循环，会返回新数组，可以用try打断
const arr = [1,2,3]
let a = arr.some(item => {
   return item > 2
}) // false
```

8.Array.every

```js
//如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测
//如果所有元素都满足条件，则返回 true
//every不会改变原数组，every不会检查空数组
// 不能用break；return跳出当前循环，会返回新数组，可以用try打断
const arr = [1,2,3]
let a = arr.every(item => {
   return item > 2
}) //false
```



###### 对象遍历

1.for..in..

```js
const obj = {a:1,b:2,c:3}
for(var i in obj) {
    console.log(i)
}// a  b  c
```

2.Object.keys

3.Object.values



##### 深浅拷贝（只针对引用数据类型）[参考](https://www.jianshu.com/p/35d69cf24f1f)

###### 浅拷贝

1. Object.assign()
2. concat()
3. slice()  返回选中数组

###### 深拷贝

1. JSON.parse(JSON.stringify()) 

   1.会忽略undefined

   2.不能解决循环引用的对象

   3.不能序列化函数

2. 手写递归

```js
//未解决循环引用的对象，解决循环引用的对象使用哈希表（不会，安详.jpg）
function clone(obj) {
    if (obj === null) return null
    if (typeof(obj) !== 'Object') return obj
    if (obj.constructor === Date) return new Date(obj)
    if (obj.constructor === RegExp) return new RegExp(obj)
    let newObj = new obj.constructor()
    for(key in obj) {
       if(typeof(obj[key]) === 'Object') clone(obj[key])
       else newObj[key] = obj[key]
    }
    return newObj
}
```



##### 防抖

概念：n秒内函数只执行一个，若n秒内再次触发则重新计算时间

```js
/**
 * @desc 函数防抖
 * @param func 函数
 * @param wait 延迟执行毫秒数
 * @param immediate true 表立即执行，false 表非立即执行
 */
debopunce(func,wait,immediate) {
    let timer;
    return function() {
        const that = this
        const args = argements
        if(timer)clearTimeout(timer)
        if(immediate) {
            // 立即执行版，触发事件后立即执行，n秒内不触发再执行
            const callNow = !timer
            timer = setTimeout(() => {
                timer = null
            },wait)
            if(callNow) func.apply(that,args)
        }else {
            // 非立即执行版，触发事件后不立即执行函数，n秒后执行，n秒内触发重新计算
            timer = setTimeout(() => {
                func.apply(context,args)
            },wait)
        }
    }
}
```



##### 节流

连续触发事件但n秒内只执行一次函数。

```js
/**
 * @desc 函数节流
 * @param func 函数
 * @param wait 延迟执行毫秒数
 * @param type 1 表时间戳版，2 表定时器版
 */
function throttle(func,wait,type) {
    if(type === 1) {
        let previous = 0
    }else {
        let timer
    }
    return function() {
        const that = this
        const args = arguments
        if(type===1) {
            let now = Date.now()
            if(now-previous>wait){
                func.apply(that,args)
                previous = now
            }
        }else {
            if(!timer){
                setTimeout(()=>{
                	timer = null
                	func.apply(that,args)
            	},wait)
            }
        }
    }
}
```



## TS

##### 新增

1. interfaces 接口
2. classes 类
3. enumerated types 枚举(带名字的常量)类型
4. generics 泛型 <T>
5. modules 模块

##### 区别

ts是面向对象编程语言，js是基于对象的脚本语言

ts支持可选参数，js不支持

ts支持静态类型，js不支持

ts支持接口，js不支持

ts开发时就能给出编译错误，js需要运行时才可以

ts属于强类型语言，js属于弱类型语言

##### 泛型，any和unknown

any表示任意类型

unknown表示未知类型，3.0引入用于替代any。不能给除了any和unknown的其他类型赋值，不能执行unknown类型变量的方法。

##### void和never区别

void表示无类型。函数无返回值或返回undefined。

never表示永远不存在的值，例如抛出异常或者死循环。



## HTML



## 浏览器

##### 缓存[参考](https://www.cnblogs.com/chengxs/p/10396066.html)

###### 缓存过程

应答模式。

第一次请求：根据服务器的缓存结果决定是否缓存和缓存方式。

###### 强缓存

概念

向浏览器缓存查找请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。

情况：

1。不存在缓存结果和标识，强缓存失效，向服务器请求

2.存在缓存结果和标识，但是结果失效，缓存失效，采用协商缓存

3.存在缓存结果和缓存标识，结果未失效，强缓存生效，直接返回结果

字段控制规则及优先级

Cache-Control  >  Expires

Cache-Control（http/1.1）取值

1.public：缓存所有内容（客户端和服务端都可缓存）

2.private：默认值，只有客户端可以缓存

3.no-cache: 客户端缓存，需要经过协商缓存验证

4.no-store: 不缓存

5.max-age=xxx：缓存内容xxx秒后失效

Expires

http/1.0，值为缓存结果到期时间，原理是用客户端和服务端返回时间做对比，若有时差或其他因素会导致缓存失效

###### 协商缓存

概念

强缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。

情况：

1.生效，返回304 (302暂时重定向)

2.失效，返回200 和请求结果

字段

Etag/if-None-MAtch > Last-Modified/If-Modified-Since

Last-Modified/If-Modified-Since：适合不重要量大的资源

last-modified 最后被修改的时间，if-modified-since 客户端再次发起请求时，携带上次lat-modefied的值，通过此字段告诉服务器该资源上次请求返回的最后修改时间。服务器收到后与服务器资源的最后修改时间做对比，若服务器最后修改时间大于last-modified，则重新请求，返回200，否则从缓存返回，304。

Etag/if-None-Match:适合重要量小的资源

Etag：服务器返回资源文件的唯一标识。

if-None-Match：服务器将etag和资源中的etag对比，一致返回304，不一致返回200。

###### 缓存位置和读取顺序

memory（内存）—> disk（硬盘）

内存缓存特点：

1.快速读取

2.时效性： 进程关闭则清空

3.js和图片文件解析后存储

硬盘缓存特点

1.需要对硬盘文件进行I/O操作

2.读取复杂，速度慢

3.css文件存贮，所以每次渲染都从硬盘中读取



##### http1.0 , http1.1 和 http2.0[参考](https://www.cnblogs.com/heluan/p/8620312.html)（应用层）

影响http请求因素：

1.带宽

2.延迟：

 2.1浏览器阻塞：浏览器对于同一个域名有连接限制，超过连接限制后续请求就会被阻塞。

2.2 DNS查询：通过DNS缓存可以减少时间

2.3建立连接：通过tcp协议建立连接，但是连接无法复用导致启动慢。

|                          | http1.0                   | http1.1                                                      |
| ------------------------ | ------------------------- | ------------------------------------------------------------ |
| 缓存策略                 | if-modified-since/expires | etag/if-none-match                                           |
| 带宽优化及网络连接的使用 | 传输整个对象              | 请求头设置range允许传输部分，返回206.  Range: bytes=0-801  响应头：content-Range: bytes 0-800/801 // 801文件总大小 |
| 错误通知                 |                           | 新增24个错误响应码（409—表示请求的资源和当面状态发生冲突；410-服务器资源永久删除） |
| host请求头               | 一台服务器绑定一个唯一ip  | 一台服务器多个ip                                             |
| 长连接(保持连接)         | 每次连接都要重新创建      | connection:keep-alive  当网页打开完成后，客户端和服务器端的链接不会关闭，当客户端再次访问这个服务器时，会继续使用这条连接。 |

|                | http2.0                                                      | http1.x                                                  |
| -------------- | ------------------------------------------------------------ | -------------------------------------------------------- |
| 新的二进制格式 | 二进制                                                       | 基于文本                                                 |
| 多路复用       | 多个请求并行执行，某个任务阻塞，不影响后续任务执行           | 若干请求串行单线程处理。某个请求阻塞，影响后续任务执行。 |
| head压缩       | （HPACK算法）使用encode来减少header大小，客服端服务器端各自存一份header fields表，差量更新 | 每次重复发送                                             |
| 服务端推送     | 允许服务端推送                                               |                                                          |



##### TCP三次握手四次挥手；和UDP的区别（传输层）

三次握手：

第一次:  发送同步SYN = 1(建立同步序号，只有在建立连接时才会被置1，握手完成后置为0),序列号seq = x

第二次:  发送同步SYN = 1,确认ACK=1(只有ACK当1时有效，0无效)，序列号seq = y,确认号ack=x+1

第三次：ACK = 1,seq = x+1, ack = y+1

![image-20210806195102781](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fddrvcn.oss-cn-hangzhou.aliyuncs.com%2F2019%2F5%2Fjyyymq.gif&refer=http%3A%2F%2Fddrvcn.oss-cn-hangzhou.aliyuncs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1630842633&t=b8bf0d9b5da53b4d8824b4541c08b343)

四次挥手

第一次：FIN=1(终止信号),seq=u

第二次：ACK=1，seq=v，ack=u+1

第三次：ACK=1,FIN=1,ack=u+1,seq=w

第四次:  ACK=1，ack=w+1,seq=u+1

![image-20210806200059132](https://img2.baidu.com/it/u=1232646660,1291971488&fm=26&fmt=auto&gp=0.jpg)

![image-20210806200930483](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210806200930483.png)

|                | TCP                              | UDP          |
| -------------- | -------------------------------- | ------------ |
| 连接方式       | 面向连接                         | 无连接       |
| 可靠性         | 无差错不丢失不重复               | 不可靠       |
| 实时性         | 低                               | 高           |
| 对系统资源要求 | 多                               | 少           |
| 特点           | 可靠有序                         | 简单快速实时 |
| 丢包处理       | 缓存后续包，等前面包重传完毕继续 |              |
| 检测数据完整性 | 检查                             | 不检查       |
|                | 一对一                           | 一对多       |

###### TCP解决丢包

:link:https://www.cnblogs.com/albert32/p/13428000.html

1.数据分片：发送端对数据进行分片处理，接收端进行数据重组。分片由TCP控制大小

2.接受确认：接收端收到后对发送端发送确认信息

3.超时重发：发送端设置定时器，若定时器内未收到确认信息，则重新发送分片数据。

4.滑动窗口（接收端可处理的数据大小）：防止接收端数据溢出，TCP提供流量控制。

5.失序处理：TCP对收到的数据进行排列处理，将正确的顺序交给应用层。

6.重复数据：丢弃重复数据

7.校验和：TCP对收到的数据进行校验，若校验不通过则丢弃并且不确认。可能会重发。

###### TCP错误恢复机制：TCP重传（数据包丢失）

###### UDP解决丢包

1.数据太大丢包：对包进行切割或者设置socket接受缓冲。

2.发送频率太快：设置socket进行缓冲

3.接收端处理时间太长：将包存入缓存区，然后迅速返回继续recv。



##### DNS劫持和HTTP劫持

DNS原理：网址的电话本，将域名翻译为IP

DNS劫持：输入域名A，返回域名B

应用场景：引流。访问无广告网址A，DNS将A网站下载后加了广告并上传至ipB，将ipB返给用户。

http劫持步骤：（一般由运营商网关）

1.标识http连接。

2.篡改http响应体，可以通过网关来获取数据包进行内容的修改。

3.将篡改的包传给用户，并将正常包丢弃。

手段：插入静态js或httpcontent，或将整体替换成iframe，在顶层iframe进行内容植入。

防范：

1.使用https加密传输

2.将数据包进行拆分，使得运营商无法标记tcp

3.对DOM节点进行监听，更改时告警。



##### 性能检测工具

1.谷歌LightHouse

2.pageSpeed Insignts

###### 性能优化

1.减少http请求

   1.1 保持页面整洁，减少资源，

   1.2 合理设置缓存

   1.3 雪碧图

2.懒加载

3.script标签置地，css放在head

4.避免频繁dom操作

5.服务器压缩

6.webpack压缩

7.不写无意义的函数和变量





## VUE

##### MVM 和 MVVM[参考](https://blog.csdn.net/qq_42068550/article/details/89480350)

|        | MVC                                                          | MVVM                                                         |      |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ---- |
| 数据流 | 单向                                                         | 双向绑定                                                     |      |
| 概念   | M:modle(业务模型)<br />V:View<br />C:controller              | M:model<br />V:View<br />VM:ViewModel                        |      |
| 区别   | C处理数据，导致C变得臃肿，并且C承担了数据解析的功能（本不应该承担） | VM进行数据解析，将解析后的结果传递给C                        |      |
| 好处   | 耦合性低，重用性高，生命周期成本低，可维护性高，部署快，可维护性高 | 1.低耦合（业务逻辑和视图逻辑与视图分离）<br />2.可复用性高<br />3.独立开发 |      |
| 缺点   | 1.不适合中小型项目（严格遵守导致操作复杂）<br />2.C和V联系紧密，V没有C很难独立应用，若但是C里面包含业务逻辑，将导致复用性降低 |                                                              |      |

##### Vue双向绑定[参考](https://www.cnblogs.com/zhenfei-jiang/p/7542900.html)

实现方式：vue实例化的时候通过Object.definePropety()加上订阅者-观察者模式实现。

模块功能

Observe：进行数据劫持

Watch：通知数据视图变化，添加订阅者

Dep：订阅者，每个v-model或{{}}都是一个dep

Compile：解析指令为真正的html，例如v-on

###### vue2.x监听数组

:link:https://juejin.cn/post/6844903990870687752

:link:https://juejin.cn/post/6844903987250987022

重写数组的方法进行监听。重写时将数组方法名对应的原始方法调用一遍并将执行结果返回，还通过ob.def.notify()将当前数组的变更通知给订阅者，将变化体现到页面上。重写完需要将重写方法应用到数组上，用hasProto()判断浏览器是否有proto属性，有就直接链接到原型上，没有就添加到当前数据对象上。

###### vue2.0对象

先判断是不是对象，是对象进行递归，然后往下走。

##### Object.definePropety 和 Proxy

|                    | Object.definePropety | Proxy                        |
| ------------------ | -------------------- | ---------------------------- |
| vue版本            | 2.x                  | 3.0                          |
| 监听对象和数组属性 | 需要深度遍历         | 可以直接代理，无需遍历       |
| 新增属性           | 需要重新遍历对象     | 能够直接代理                 |
| 兼容性             | 好                   | 不兼容IE，需求浏览器版本较高 |

##### Diff算法[参考](https://www.cnblogs.com/wind-lanyan/p/9061684.html)



##### Vue3.x和Vue2.x的区别

###### 默认懒观察

3.x中只会对渲染初始可见部分的数据创建观察者。

2.x中一开始就会创建观察者。

###### 更精准的变更通知

3.x中只有依赖那个属性的 watcher 才会重新运行。

2.x中所有对象的watcher都会重新运行。

###### 生命周期变更

删除beforeCreate，created，其余生命周期前加on



## VUEX

##### Vuex永久保存

插件: persistedState

```js
// 自己实现
new store = new Vuex.Store({
    plugins: [my{lugin}]
})
const myPlugin = store => {
    store.subscribe((mutation,state) => {
        localStorage.setItem("store", JSON.stringift(state))
    })
}
```



##### vuex原理



## VUE Router

:link:https://zhuanlan.zhihu.com/p/27588422

###### 更新视图但是不请求页面

默认模式：hash

##### 原理

###### hash模式 # IE8+（#开始到url末尾）

location.hash

hash改变，触发hashchange回调，改变页面

\# 后面的符号不包含在请求中

###### html5新增的history模式 IE10+

需要后台处理配置的路由路径，不然会报错。

history  API

用onpopstate来监听url变化

** 不会立即发送请求

history.replaceState()

history.pushState()

html4支持：

history.forward()

history.back()

history.go()

hash模式必须不一样才会添加到栈中（浏览器的历史记录栈），history可以一样。

##### 路由懒加载

1.import和匿名函数导入

````js
const List = () => import('@/components/list.vue')
const router = new VueRouter({
    routes:[{path: '/list',component:list}]
})
````

2.require引入

```js
const router = new Router({
    routes: [{
        path: '/list',
        component: (resolve) => {
            require(['@/components/list'],resolve)
        }
    }]
})
```

###### vueRouter 刷新页面数据但是不刷新页面

利用pushState属性，在页面前进的时候动态修改了history的内容，添加一条记录，接着location跟着变，同时获取对应的js文件将资源挂载到dom上。

###### abstract模式

不符合以上两种情况（非浏览器环境）则进入该模式，适用所有的JavaScript环境，包括node.js。



## 前端工程化，模板化，组件化

##### 前端工程化

用工程的思维去看待自己的项目，比如结构，样式和动作分离。模板化和组件化就是工程化的表现形式。

组织层面：代码规范，技术选型，项目构建优化

代码层面：JS，CSS模块机，UI组件化

##### 模板化

c​o​m​m​o​n​js​和​es​moudle:link:https://baijiahao.baidu.com/s?id=1707938563869146819&wfr=spider&for=pc

可以复用和分治的模块

JS模块方案：CommonJS/AMD/UMD/ES6 Moudle

|      | CommonJS | AMD | CMD |UMD | ES6 Moudle |
| ---- |------- | ---- | --| ----- | ---------- |
| 运行环境 | 服务器端 | 浏览器 |浏览器|   | 浏览器 |
| 同步异步 | 同步 | 异步 | | |  |
| 加载的文件资源位置 | 本地资源 |  | |  |  |
| 执行环境 | node.js | require.js | sea.js，node.js | webpack | node |
| 运行命令 | require，module.export<br />输出为值的拷贝 | define：定义模块，require：导入其他模块，return：对外输出接口，define.amd：AMD规范标识 | define: 定义全局函数，<br />require：引入依赖，<br />export：提供向外接口 |  |import：导入其他模块<br />export：到处其他模块|

CSS：less，sass，stylus

##### 组件化

将页面视为一个容器，例如头部，侧边栏，底部等





## uniAPP

##### 小程序生命周期

onLaunch (仅触发一次)  小程序加载完成

onshow  小程序显示

onHide  小程序隐藏

onErroe  错误监听函数

onPageNotFound  页面不存在监听函数

##### 页面生命周期

onLoad   页面初始化

onReady   页面渲染完成

onShow   页面显示

onHide   页面隐藏

onUnload  页面卸载

onPullDownRefresh  下拉刷新

onReachBottom   触底事件

onShareAppMessage   分享

onPageScroll  页面滚动

onTabItemTab   tab

##### 组件生命周期

同vue (没有keep-alive的生命周期)

##### 小程序的优化

框架设计层面

1.逻辑层，视觉层分离，避免JS运算阻塞视图渲染

2.单独定义组件标签(wxml)，减少DOM复杂度

3.精简样式(wxss)，提升渲染性能

4.复杂组件原生化(video/map等)，解决web组件的功能/体验缺失

setData原理

小程序使用webview作为渲染载体，逻辑层用独立的js作为运行环境。在架构上，webview和js都是独立模块，不具备共享的通道，webview和js的数据传输通过evaluateJavaScript实现，微信将evaluateJs封装成了setData js方法。

setData每次被频繁调用或传递数据量过大可能会造成性能问题。

###### uniapp对setdata优化

差量更新

先于历史数据进行对比，计算出有变化的部分，对有变化的部分进行更新。

减少调用频率

基于vue runtime(非完整版，无compiler)深度定制实现，并借助了vue的nextTick机制。



## Nginx

##### 正向代理

代替客户端去访问服务器

作用：

1.隐藏客户端行踪

2.客户端访问授权，若没有权限则丢弃数据包

3.缓存作用。若客户端A访问了服务器，代理端将保存服务器端数据一段时间。当客户端B访问服务器时，可以直接从缓存中返回数据。

4.访问无法访问的服务器。

##### 反向代理

代理服务器

作用：

1.隐藏真实服务器ip，客户端无需操作，用户无感知



## Webpack

##### Loader

本质：转换器，将其他文件转为js代码，因为webpack只能识别js代码。

执行时机：webpack初始化时

配置：module.rules

##### Plugin

本质：插件，扩展webpack功能

执行时期：webpack整个生命周期

配置：plugins



### 算法

##### 冒泡排序

```js
function maopaosort(arr){
    for(let i=0;i<arr.length-1;i++) {
        for(let j=0;j<arr.length-1-i;j++) {
            if(arr[j]>arr[j+1]) {
            	let temp = arr[j+1]
                arr[j+1] = arr[j]
                arr[j] = temp
            }
        }
    }
    return arr
}
```





